<!DOCTYPE html>
<!--  This site was created in Webflow. http://www.webflow.com  -->
<!--  Last Published: Tue Aug 04 2020 19:31:41 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="5f280da840b6dbdf24f167eb" data-wf-site="5f280da840b6db7e3ef167ea">
<head>
  <meta charset="utf-8">
  <title>Mindmapping</title>
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/mindmapping.webflow.css" rel="stylesheet" type="text/css">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Lato:100,100italic,300,300italic,400,400italic,700,700italic,900,900italic"]  }});</script>
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>
</head>
<body class="body">
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.4.1.min.220afd743d.js?site=5f280da840b6db7e3ef167ea" type="text/javascript" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
  <script src="index.js"></script>

  <!--<script>




  // Default variables

  var state = 0;
  // 0 = No actions
  // 1 = Editing node text
  // 2 = Dragging node
  // 3 = Drawing connection
  // 4 = Deleting connections

  var onEmpty = 1;
  // 0 = Mouse is hovering on empty canvas
  // 1 = Mouse is hovering over element

  var mX = 0; // Mouse x position
  var mY = 0; // Mouse y position
  var clickedX = 0; // X position of last click
  var clickedY = 0; // Y position of last click
  var mouseMoved = 0; // State of mouse movement between click and release

  var nodes = [];
  var connections = [];

  var nodeCount = 0;
  var connectionCount = 0;

  var clicked;
  var connecting;

  var xOffset = 0;
  var yOffset = 0;
  var selectedConnections = [];



  // Add default mouse interactions to body

  d3.select('body')
    .on('mousedown', bodyMouseDown)
    .on('mouseup', bodyMouseup)
    .on('mousemove', bodyMouseMove)
    .on('dblclick', bodyDBClick)
    .on('contextmenu', bodyRClick);



  // Functions

  function bodyMouseDown() {

    // Set mouse movement tracking variable to default

    mouseMoved = 0;


    if (state < 2) {

      // Reset state
      // Un-focus all nodes *****
      // Update last clicked position

      state = 0;
      clickedX = mX;
      clickedY = mY;


      if (onEmpty) {

        if (event.button == 2) {

          // Create p5 sketch for cutting line
          // Set state to 4 (cutting connections)

          createConnection('cuttingTool', mX, mY, mX, mY);
          state = 4;
        }
      }
    }
  }



  function bodyMouseup() {

    if (state == 2) {

      // Release dragged nodes

      let x = getElementCenterX(clicked);
      let y = getElementCenterY(clicked);
      let a = getConnectionEndPointsFromObj(clicked, clickedX, clickedY);

      for (let i = 0; i < a.length; i++) {

        a[i][1][2 - a[i][2]] = x;
        a[i][1][3 - a[i][2]] = y;
      }

      nodes[getIndexFromID(clicked.attr('id'))][0] = x;
      nodes[getIndexFromID(clicked.attr('id'))][1] = y;
      selectedConnections.length = 0;
      state = 0;
    }


    if (state == 3) {

      // Delete in-progress connections

      if (onEmpty) {

        connecting.remove();
        state = 0;
      }
    }


    if (state == 4) {

      // Delete "cut" connections
      // Delete cutting tool sketch
      // Reset state to default

      for (let i = 0; i < connections.length; i++) {

        let a = connections[i];

        a[5] = Math.floor(intersects(a[0], a[1], a[2], a[3], clickedX, clickedY, mX, mY));
        if (a[5]) { d3.select('#connection-' + i).remove(); }
      }
      connecting.remove();
      state = 0;
    }
  }



  function bodyMouseMove() {

    // Reset onEmpty to default (will be turned false on element hover)

    onEmpty = 1;


    // Set mouse movement tracking variable to true (moved)

    mouseMoved = 1;


    // Update mouse x, y positions

    mX = event.clientX;
    mY = event.clientY;


    if (state == 2) {

      // Update dragged node position
      // Update attached connections' size/position

      let x = getElementCenterX(clicked);
      let y = getElementCenterY(clicked);

      clicked.style('margin-left', (mX + xOffset) + 'px')
        .style('margin-top', (mY + yOffset) + 'px');

      if (selectedConnections.length > 0) {
        for (let i = 0; i < selectedConnections.length; i++) {

          let obj = selectedConnections[i];
          let x2 = obj[1];
          let y2 = obj[2];
          let dir = (((x < x2) && (y < y2)) || ((x > x2) && (y > y2)));

          resizeElement(obj[0], x, y, x2, y2);
          drawLine(obj[3], x, y, x2, y2, 0, 0);
        }
      }
    }


    if (state == 3) {

      // Update drawn connection position/size

      let dir = (((clickedX < mX) && (clickedY < mY)) || ((clickedX > mX) && (clickedY > mY)));

      resizeElement(connecting, clickedX, clickedY, mX, mY);
      drawLine(sketchId, clickedX, clickedY, mX, mY, 0, 0);
    }


    if (state == 4) {

      // Draw cutting line
      // Check for connection line cuts
      // Highlight connection selected for cutting

      let dir = (((clickedX < mX) && (clickedY < mY)) || ((clickedX > mX) && (clickedY > mY)));

      resizeElement(connecting, clickedX, clickedY, mX, mY);
      drawLine(sketchId, clickedX, clickedY, mX, mY, 1, 0);

      for (let i = 0; i < connections.length; i++) {

        let a = connections[i];

        a[5] = Math.floor(intersects(a[0], a[1], a[2], a[3], clickedX, clickedY, mX, mY));
        drawLine(a[4], a[0], a[1], a[2], a[3], 0, a[5]);
      }
    }

  }



  function bodyDBClick() {

    if (onEmpty) {

      if (!mouseMoved) {

        if (state == 0) {

          // Create new node at mouse position

          createNode(-1, clickedX, clickedY);
        }
      }
    }
  }



  function bodyRClick() {

    // Prevent contextmenu from showing

    event.preventDefault();
  }



  function nodeHover() {

    // Set onEmpty to false to disable stacking new nodes
    // Display node handle

    onEmpty = 0;

    d3.select(this)
       .select('div.text_bubble_handle')
       .style('opacity', '100%');
  }



  function nodeHoverOut() {

    // Hide node handle

    d3.select(this)
       .select('div.text_bubble_handle')
       .style('opacity', '0%');
  }



  function nodeHandleMouseDown() {

    // Set onEmpty to false to disable stacking new nodes

    onEmpty = 0;


    // Set state to 2 (dragging node)
    // Save node parent to "clicked"
    // Save x, y offsets between mouse and element position
    // Add child connections to an array

    if (state < 2) {
      state = 2;
      clicked = d3.select(this.parentNode);
      clickedX = getElementCenterX(clicked);
      clickedY = getElementCenterY(clicked);

      xOffset = (parseInt(clicked.style('margin-left'), 10) - mX);
      yOffset = (parseInt(clicked.style('margin-top'), 10) - mY);

      let a = getConnectionEndPointsFromObj(clicked, clickedX, clickedY);

      for (let i = 0; i < a.length; i++) {

        selectedConnections.push([d3.select('#' + a[i][0]), a[i][1][2 - a[i][2]], a[i][1][3 - a[i][2]], a[i][1][4]]);
      }
    }
  }




  function nodeChildMouseDown() {

    // Set onEmpty to false to disable stacking new nodes

    onEmpty = 0;


    // If possible...
    // Save node parent to "clicked"
    // If left clicked, set state to 1 (editing)
    // If right clicked, create connection and set state to 3 (drawing connection)

    if (state < 2) {

      // Save object into "clicked"

      clicked = d3.select(this.parentNode);


      if (event.button == 0) {

        state = 1;

      } else if (event.button == 2) {

        // Update last clicked position

        clickedX = getElementCenterX(clicked);
        clickedY = getElementCenterY(clicked);


        // Prevent default context menu from showing
        // Create new connection
        // Set state to 3 (drawing connection)

        event.preventDefault();
        createConnection(-1, clickedX, clickedY, mX, mY);
        state = 3;
      }
    }
  }



  function nodeChildMouseUp() {

    if (state == 3) {

      // If drawing connection, check if this was the starting point
      // If so delete connection...
      // If not snap connection to this node's center
      // Save connection info to the connections array
      // Add connection id to parents' info arrays
      // Increment total number of connections by one

      let releasedOn = d3.select(this.parentNode);

      if (releasedOn != clicked) {

        let x2 = getElementCenterX(releasedOn);
        let y2 = getElementCenterY(releasedOn);

        let thisId = connecting.attr('id');
        let clickedId = clicked.attr('id');
        let releasedOnId = releasedOn.attr('id');

        resizeElement(connecting, clickedX, clickedY, x2, y2);
        drawLine(sketchId, clickedX, clickedY, x2, y2, 0, 0);
        connections.push([clickedX, clickedY, x2, y2, sketchId]);
        nodes[getIndexFromID(clickedId)][2].push(thisId);
        nodes[getIndexFromID(releasedOnId)][2].push(thisId);
        connectionCount++;

      } else {

        connecting.remove();
      }

      selectedConnections.length = 0;
      state = 0;
    }
  }



  function nodeInput() {/*

    // Update attached connections when typing

    let obj = d3.select(this.parentNode);

    let x2 = getElementCenterX(obj);
    let y2 = getElementCenterY(obj);

    obj = d3.select(nodes[getIndexFromID(obj.attr('id'))])

    let a = getConnectionEndPointsFromObj(clicked, clickedX, clickedY);

    for (let i = 0; i < a.length; i++) {

      a[0][2 - num] = getElementCenterX(clicked);
      a[0][3 - num] = getElementCenterY(clicked);
    }*/
  }





  function createNode(id, x, y) {

    // Check if old or new id should be used and define it
    // If new, increment total number of nodes by one
    // Create id string
    // Push new node object to the "nodes array"

    state = 1;
    let id2 = nodeCount;
    if (id != -1) { id2 = id; } else { nodeCount++; }
    let id3 = 'node-' + id2;
    nodes.push([x, y, []]);


    // Create new node with given parameters
    // Save the node's text containing child in "clicked"

    d3.select('body')
      .append('div')
      .classed('text_bubble_wrap', true)
      .attr('id', id3)
      .style('margin-left', (x - 14) + 'px')
      .style('margin-top', (y - 32) + 'px')
      .style('z-index', '10')
      .on('mouseenter', nodeHover)
      .on('mouseleave', nodeHoverOut)
      .call(function(parent) {

        parent.append('div')
          .classed('text_bubble_handle', true)
          .on('mousedown', nodeHandleMouseDown)
          .append('div')
          .classed('handle_line_and_circle', true)
          .call(function(parent) {

            parent.append('div')
              .classed('handle_circle', true);

            parent.append('div')
              .classed('handle_line', true);
          });

        parent.append('div')
          .style('display', 'inline-block')
          .on('mousedown', nodeChildMouseDown)
          .on('mouseup', nodeChildMouseUp)
          .call(function(parent) { clicked = parent.parentNode; })
          .append('p')
          .classed('text_bubble', true)
          .attr('contenteditable', 'true')
          .on('input', nodeInput)
          .node().focus();
      });
  }



  function createConnection(id, x, y, x2, y2) {

    // Check if old or new id should be used and define it
    // Create id string
    // Create connection box

    let id2 = connectionCount;
    if (id != -1) { id2 = id; }
    let id3 = 'connection-' + id2;

    d3.select('body')
      .append('div')
      .attr('id', id3)
      .style('position', 'absolute')
      .style('z-index', '0')
      .call(function(parent) {
        connecting = parent;
      });

    createP5Canvas(id3);

    connecting.select('canvas')
      .style('width', '100%')
      .style('height', '100%');

    // Set connection position/size
    // Draw connection line

    resizeElement(connecting, x, y, x2, y2);
    drawLine(sketchId, x, y, x2, y2, 0, 0);
  }



  function createP5Canvas(pId) {

    // Create p5 sketch bound to given parent id

    new p5(sketch_connection, pId)

    function sketch_connection(p) {

      sketchId = p;
      sketchId.setup = function () {
        sketchId.createCanvas(0,0);
        sketchId.noFill();
        sketchId.strokeWeight(2);
      }
    }
  }



  function drawLine(sketchId, x, y, x2, y2, lineType, selected) {

    // Draw bezier line between connection points

    let w = Math.abs(x - x2);
    let h = Math.abs(y - y2);
    let dir = (((x < x2) && (y < y2)) || ((x > x2) && (y > y2)));

    sketchId.resizeCanvas(w, h);
    sketchId.clear();
    sketchId.stroke('#2F323A');
    if (selected) { sketchId.stroke(255); }

    if (!lineType) { sketchId.bezier(w * (!dir), 0, w / 2, 0, w / 2, h, w * dir, h); }
    else { sketchId.line(w * (!dir), 0, w * dir, h); }
  }



  function resizeElement(obj, x, y, x2, y2) {

    // Reposition and resize element

    obj.style('margin-left', Math.min(x, x2) + 'px')
    .style('margin-top', Math.min(y, y2) + 'px')
    .style('width', Math.abs(x - x2) + 'px')
    .style('height', Math.abs(y - y2) + 'px');
  }



  function getElementCenterX(obj) {

    // Calculate and return centered X position of element

    return parseInt(obj.style('margin-left'), 10) + Math.floor(parseInt(obj.style('width'), 10) / 2);
  }



  function getElementCenterY(obj) {

    // Calculate and return centered Y position of element

    return parseInt(obj.style('margin-top'), 10) + Math.floor(parseInt(obj.style('height'), 10) / 2);
  }



  function getIndexFromID(id) {

    // Extract array index from element id

    return id.split('-')[1];
  }



  function getConnectionEndPointsFromObj(obj, x, y) {

    // Get connections attached to object
    // Return connection arrays and indexes for positions matching argument positions

    let a = [];
    let nodeConnections = nodes[getIndexFromID(obj.attr('id'))][2];
    for (i = 0; i < nodeConnections.length; i++) {
      let c = connections[getIndexFromID(nodeConnections[i])];
      let num = ((c[2] == x) && (c[3] == y)) * 2;
      a.push([nodeConnections[i], c, num]);
    }
    return a;
  }



  function intersects(a,b,c,d,p,q,r,s) {

    // returns true iff the line from (a,b)->(c,d) intersects with (p,q)->(r,s)

    var det, gamma, lambda;
    det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
      return false;
    } else {
      lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
      gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
      return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
    }
  }


  </script>-->

</body>
</html>
