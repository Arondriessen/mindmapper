<!DOCTYPE html>
<!--  This site was created in Webflow. http://www.webflow.com  -->
<!--  Last Published: Tue Aug 04 2020 19:31:41 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="5f280da840b6dbdf24f167eb" data-wf-site="5f280da840b6db7e3ef167ea">
<head>
  <meta charset="utf-8">
  <title>Mindmapping</title>
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/mindmapping.webflow.css" rel="stylesheet" type="text/css">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Lato:100,100italic,300,300italic,400,400italic,700,700italic,900,900italic"]  }});</script>
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>
</head>
<body class="body">
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.4.1.min.220afd743d.js?site=5f280da840b6db7e3ef167ea" type="text/javascript" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>

  <script>

    var dragging = 0;
    var x = 0;
    var y = 0;
    var width = 0;
    var height = 0;
    var clicked = 0;
    var clickedX = 0;
    var clickedY = 0;
    var onEmpty = 1;
    var editing = 0;
    var dragged = 0;
    var connecting = 0;
    connecting2 = 0;
    var x1 = 0;
    var y1 = 0;
    var x2 = 0;
    var y2 = 0;
    var releasedOn = 0;
    var bubbles= [];
    var connections = [];
    var draggedConnections = [];
    var draggedConnectionEndPoints = [];
    var connectionBoxW = 0;
    var connectionBoxH = 0;
    var sketchId;
    var deletingConnections = 0;
    var switchAng = -1;
    var debugIndex = [[bubbles, "Nodes"], [connections, "Connections"]];

    document.onmousemove = function(e) {
      x = e.clientX;
      y = e.clientY;
      var body = document.body,
      html = document.documentElement;
      width = Math.max( body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth );
      height = Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
      onEmpty = 1;

      if (dragged != 0) {
        draggingBubble();
      }

      if (connecting != 0) {
        connectingBubbles();
      }

      if (deletingConnections) {
        checkForConnectionCuts();
      }
    }

    d3.select('body')
      .on('mousedown', bodyMouseDown)
      .on('mouseup', bodyMouseUp)
      .on('contextmenu', bodyLClick)
      .on('dblclick', bodyDBClick)

      // Debug Panel

      .append('div')
      .classed('debug_panel', true)
      .call(function(parent) {
        parent.append('p')
          .classed('p_debug', true); // Nodes
        parent.append('p')
          .classed('p_debug', true); // Connections
      });


    function updateDebugPanel() {
      d3.select('div.debug_panel')
        .selectAll('p')
        .data(debugIndex)
        .text(function(d) { return (d[1] + ": " + d[0].length); });
    }

    function bodyMouseDown() {
      clickedX = x;
      clickedY = y;
      deletingConnections = 0;
      switchAng = -1;
      if (onEmpty) {
        clicked = 0;

        if (event.button == 2) {
          deletingConnections = 1;
        }
      }
    }

    function bodyMouseUp() {
      if (onEmpty) {
        if (editing) {
          editing = 0;
        }
        if (connecting != 0) {
          connecting.remove();
          connecting = 0;
          clicked = 0;
        }
      }
      if (deletingConnections) {
        deleteSelectedConnections();
      }
      dragged = 0;
      deletingConnections = 0;
      switchAng = -1;
    }

    function bodyLClick() {
      event.preventDefault();
    }

    function bodyDBClick() {
      if (onEmpty) {
        if (!editing) {
          if ((clickedX == x) && (clickedY == y)) {

            d3.select(this)
              .append('div')
              .classed('text_bubble_wrap', true)
              .call(function(parent) { bubbles.push(parent); })
              .style('margin-left', Math.floor(x - 14) + 'px')
              .style('margin-top', Math.floor(y - 32) + 'px')
              .style('z-index', '10')
              .on('mouseenter', bubbleHover)
              .on('mouseleave', bubbleHoverOut)
              .call(function(parent) {

                parent.append('div')
                  .classed('text_bubble_handle', true)
                  .on('mousedown', startDrag)
                  .on('mouseup', stopDrag)
                  .on('contextmenu', bubbleRClick)
                  .append('div')
                  .classed('handle_line_and_circle', true)
                  .call(function(parent) {

                    parent.append('div')
                      .classed('handle_circle', true);

                    parent.append('div')
                      .classed('handle_line', true);
                  });

                parent.append('div')
                  .style('display', 'inline-block')
                  .on('mousedown', bubbleMouseDown)
                  .on('mouseup', bubbleMouseUp)
                  .call(function() { clicked = this; })
                  .append('p')
                  .classed('text_bubble', true)
                  .attr('contenteditable', 'true')
                  .node().focus();

              });

            editing = 1;
            updateDebugPanel();
          }
        }
      }
    }

    function bubbleMouseDown() {
      onEmpty = 0;
      clicked = this;

      if (event.button == 0) {
        editing = 1;
      } else if (event.button == 2) {
        event.preventDefault();
        createConnectionBox();
      }
    }

    function bubbleMouseUp() {
      if (connecting != 0) {
        releasedOn = this;
        snapConnectionToBubble();
      }
    }

    function bubbleHover() {
      // Hover Onto Text Bubble
      if (dragging == 0) {
        d3.select(this)
           .select('div.text_bubble_handle')
           .style('opacity', '100%');
      }
      onEmpty = 0;
    }

    function bubbleHoverOut() {
      // Hover Off of Text Bubble
      d3.select(this)
         .select('div.text_bubble_handle')
         .style('opacity', '0%');
    }

    function bubbleRClick() {
      // Right Click
      event.preventDefault();
    }


    function startDrag() {
      // Start Dragging Bubble
      event.preventDefault();
      dragged = this.parentNode;
      xOffset = (parseInt(d3.select(dragged).style('margin-left'), 10) - x);
      yOffset = (parseInt(d3.select(dragged).style('margin-top'), 10) - y);


      for (let y = 0; y < connections.length; y++) {
        if (connections[y][1] == dragged) {
          draggedConnections.push(y);
          draggedConnectionEndPoints.push(2);
        }
        if (connections[y][2] == dragged) {
          draggedConnections.push(y);
          draggedConnectionEndPoints.push(1);
        }
      }
    }

    function draggingBubble() {
      // Dragging a Text Bubble
      d3.select(dragged)
        .style('margin-left', (x + xOffset) + 'px')
        .style('margin-top', (y + yOffset) + 'px');

      if (draggedConnections.length > 0) {
        for (let i = 0; i < draggedConnections.length; i++) {
          x1 = (parseInt(d3.select(connections[draggedConnections[i]][draggedConnectionEndPoints[i]]).style('margin-left'), 10) + Math.floor(parseInt(d3.select(connections[draggedConnections[i]][draggedConnectionEndPoints[i]]).style('width'), 10) / 2));
          y1 = (parseInt(d3.select(connections[draggedConnections[i]][draggedConnectionEndPoints[i]]).style('margin-top'), 10) + Math.floor(parseInt(d3.select(connections[draggedConnections[i]][draggedConnectionEndPoints[i]]).style('height'), 10) / 2));
          x2 = (parseInt(d3.select(dragged).style('margin-left'), 10) + Math.floor(parseInt(d3.select(dragged).style('width'), 10) / 2));
          y2 = (parseInt(d3.select(dragged).style('margin-top'), 10) + Math.floor(parseInt(d3.select(dragged).style('height'), 10) / 2));
          connectionBoxW = Math.abs(x1 - x2);
          connectionBoxH = Math.abs(y1 - y2);
          connecting2 = connections[draggedConnections[i]][0];
          connecting2.style('margin-left', Math.min(x1, x2) + 'px')
            .style('margin-top', Math.min(y1, y2) + 'px')
            .style('width', connectionBoxW + 'px')
            .style('height', connectionBoxH + 'px');

          sketchId = connections[draggedConnections[i]][3];
          drawLine(sketchId);
        }
      }
    }

    function stopDrag() {
      // Stop Dragging a Text Bubble
      draggedConnections.length = 0;
      draggedConnectionEndPoints.length = 0;
    }

    function createConnectionBox() {

      papa = clicked.parentNode;

      d3.select('body')
        .append('div')
        .attr('id', 'connection' + connections.length)
        .style('width', '0px')
        .style('height', '0px')
        .style('position', 'absolute')
        .style('z-index', '0')
        .call(function(parent) {
          connecting = parent;
        });

        new p5(sketch_connection, 'connection' + connections.length)

        function sketch_connection(p) {
          sketchId = p;
          sketchId.setup = function () {
            sketchId.createCanvas(0,0);
            sketchId.noFill();
            sketchId.stroke(0);
          }
        }
    }

    function drawLine(sketchId) {
      sketchId.resizeCanvas(connectionBoxW,connectionBoxH);
      sketchId.clear();

      let ww = sketchId.width;
      let hh = sketchId.height;
      xDir = Math.min(Math.max((x2 - x1), 0), 1);
      yDir = Math.min(Math.max((y2 - y1), 0), 1);

      for (i = 0; i < connections.length; i++) {
        if (connections[i][0] == connecting2) {

          connections[i][4] = xDir;
          connections[i][5] = yDir;
        }
      }

      //sketchId.line(ww * (!xDir), hh * (!yDir), ww * xDir, hh * yDir);
      sketchId.bezier(ww * (!xDir), hh * (!yDir), ww / 2, hh * (!yDir), ww / 2, hh * (yDir), ww * xDir, hh * yDir);
    }

    function connectingBubbles() {
      // Connecting Text Bubbles
      x1 = (parseInt(d3.select(papa).style('margin-left'), 10) + Math.floor(parseInt(d3.select(papa).style('width'), 10) / 2));
      y1 = (parseInt(d3.select(papa).style('margin-top'), 10) + Math.floor(parseInt(d3.select(papa).style('height'), 10) / 2));
      x2 = x;
      y2 = y;
      connectionBoxW = Math.abs(x1 - x2);
      connectionBoxH = Math.abs(y1 - y2);
      connecting.style('margin-left', Math.min(x1, x2) + 'px')
        .style('margin-top', Math.min(y1, y2) + 'px')
        .style('width', connectionBoxW + 'px')
        .style('height', connectionBoxH + 'px');

      connecting2 = connecting;
      drawLine(sketchId);
    }

    function snapConnectionToBubble() {
      if (releasedOn != clicked) {
        papa = releasedOn.parentNode;
        x2 = (parseInt(d3.select(papa).style('margin-left'), 10) + Math.floor(parseInt(d3.select(papa).style('width'), 10) / 2));
        y2 = (parseInt(d3.select(papa).style('margin-top'), 10) + Math.floor(parseInt(d3.select(papa).style('height'), 10) / 2));
        connectionBoxW = Math.abs(x1 - x2);
        connectionBoxH = Math.abs(y1 - y2);
        connecting.style('margin-left', Math.min(x1, x2) + 'px')
          .style('margin-top', Math.min(y1, y2) + 'px')
          .style('width', connectionBoxW + 'px')
          .style('height', connectionBoxH + 'px');

        connecting2 = connecting;
        drawLine(sketchId);
        connections.push([connecting, clicked.parentNode, papa, sketchId, xDir, yDir, -1, 0]);
        updateDebugPanel();

      } else {
        connecting.remove();
      }
      connecting = 0;
      clicked = 0;
    }

    function checkForConnectionCuts() {
      for (i = 0; i < connections.length; i++) {
        x1 = parseInt(connections[i][0].style('margin-left'));
        y1 = parseInt(connections[i][0].style('margin-top'));
        let ww = parseInt(connections[i][0].style('width'));
        let hh = parseInt(connections[i][0].style('height'));
        x2 = x1 + ww;
        y2 = y1 + hh;

        if (((x > x1) && (x < x2)) && ((y > y1) && (y < y2))) {
          let short = Math.min(ww, hh);
          let long = Math.max(ww, hh);
          let zedMax = long / short;
          switchAng = ((connections[i][4] + connections[i][5]) != 1);
          let zed = Math.abs(((zedMax - 1) * Math.abs((ww > hh) - switchAng)) - ((((y - y1) / hh)) * (zedMax - 1))) + 1;
          let yy1 = (y1 + (hh * switchAng));
          let side = (((x - x1) + (Math.max(y, yy1) - Math.min(y, yy1))) > (short * zed));
          let prevSide = connections[i][6];
          connections[i][6] = side;

          if (prevSide != -1) {
            if (side == (!prevSide)) {
              // Toggle "Mark for delete" bool
              connections[i][7] = (!connections[i][7]);
            }
          }

        } else {
          connections[i][6] = -1;
        }
      }
    }

    function deleteSelectedConnections() {
      for (i = 0; i < connections.length; i++) {
        if (connections[i][7] == 1) {
          connections[i][0].remove();
          connections.splice(i, 1);
          updateDebugPanel();
        }
      }
    }

  </script>

</body>
</html>
